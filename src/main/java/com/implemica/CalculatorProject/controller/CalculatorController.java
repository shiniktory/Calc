package com.implemica.CalculatorProject.controller;

import com.implemica.CalculatorProject.model.calculation.EditOperation;
import com.implemica.CalculatorProject.model.calculation.MathOperation;
import com.implemica.CalculatorProject.model.calculation.MemoryOperation;
import com.implemica.CalculatorProject.model.exception.CalculationException;
import com.implemica.CalculatorProject.model.InputValueProcessor;
import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.PauseTransition;
import javafx.animation.Timeline;
import javafx.application.Platform;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.event.Event;
import javafx.fxml.FXML;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.control.*;
import javafx.scene.control.TextField;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Pane;
import javafx.scene.layout.VBox;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.util.Duration;

import java.awt.*;
import java.math.BigDecimal;
import java.util.LinkedList;
import java.util.List;

import static com.implemica.CalculatorProject.model.calculation.EditOperation.*;
import static com.implemica.CalculatorProject.model.calculation.MathOperation.*;
import static com.implemica.CalculatorProject.model.calculation.MemoryOperation.MEMORY_CLEAN;
import static com.implemica.CalculatorProject.model.formatting.OutputFormatter.POINT;
import static com.implemica.CalculatorProject.model.formatting.OutputFormatter.formatEnteredNumber;
import static com.implemica.CalculatorProject.model.formatting.OutputFormatter.formatNumberForDisplaying;
import static com.implemica.CalculatorProject.model.validation.DataValidator.isDigit;
import static com.implemica.CalculatorProject.model.validation.DataValidator.isNumber;

/**
 * The {@code CalculatorController} class is a chain between calculator's view and calculations. It accepts and handles
 * events generated by mouse clicks or keyboard keys' pressings.
 *
 * @author V. Kozina-Kravchenko
 */
public class CalculatorController {

    /**
     * An instance of {@link InputValueProcessor} that accepts, transforms and calculates the results for an
     * input data.
     */
    private final InputValueProcessor valueProcessor = new InputValueProcessor();

    /**
     * The string value of a prefix for numpad digits.
     */
    private static final String NUMPAD_PREFIX = "Numpad ";

    /**
     * The string value of id for button with decimal point.
     */
    private static final String POINT_BUTTON_ID = "point";

    /**
     * The title for group calculator views used for converting values.
     */
    private static final String CONVERTER_GROUP = "\tCONVERTER";

    /**
     * A font for the title for group calculator views used for converting values.
     */
    private static final Font CONVERTER_FONT = Font.font("Segoi UI", FontWeight.BOLD, 15);

    /**
     * The list of calculator types.
     */
    private static final String[] CALCULATOR_TYPES = new String[]{"\tStandard", "\tScientific", "\tProgrammer",
            "\tDate calculation", CONVERTER_GROUP, "\tVolume", "\tLength", "\tWeight and Mass", "\tTemperature",
            "\tEnergy", "\tArea", "\tSpeed", "\tTime", "\tPower", "\tData", "\tPressure", "\tAngle"};

    /**
     * The count of milliseconds for animation duration.
     */
    private static final int ANIMATION_DURATION = 75;

    /**
     * The value of width for panel with calculator types.
     */
    private static final double VIEW_PANEL_MAX_WIDTH = 257.0;

    /**
     * The flag variable shows is panel with calculator types shown right now.
     */
    private boolean isViewPanelShown = false;

    /**
     * The flag variable shows is panel with stored in memory values shown right now.
     */
    private boolean isMemoryStorageShown = false;

    /**
     * A reference to the {@link TextField} with a value of current number value.
     */
    @FXML
    private TextField currentNumberText;

    /**
     * A reference to the {@link TextField} with a string containing current mathematical expression.
     */
    @FXML
    private TextField prevOperationsText;

    /**
     * A reference to the {@link VBox} contains controls for changing the calculator's type.
     */
    @FXML
    private VBox viewTypesPanel;

    /**
     * A reference to the {@link ListView} contains the list of calculator types.
     */
    @FXML
    private ListView<Label> viewTypesList;

    /**
     * A reference to the {@link GridPane} contains {@link Button}s with digits, mathematical operations and
     * some operations to edit entered values.
     */
    @FXML
    private GridPane numbersAndOperations;

    /**
     * A references to the buttons allows to work with memorized numbers.
     */
    @FXML
    private Button memoryClean, memoryRecall, memoryShow, memoryAdd, memorySubtract, memoryStore;

    /**
     * A reference to the {@link Pane} shows a memorized number.
     */
    @FXML
    private Pane memoryStorage;

    /**
     * The flag variable shows is error occurred while calculations.
     */
    private boolean isErrorOccurred = false;

    /**
     * Handles all events generated by keyboard key pressing.
     *
     * @param event an event instance generated by key pressing
     */
    @FXML
    private void handleKeyEvent(KeyEvent event) {
        if (isViewPanelShown) {
            showOrHideViewPanel();
        }
        KeyCode key = event.getCode();

        // Unary operations
        if (event.isShiftDown() && key == KeyCode.DIGIT2) {
            fireButton(SQUARE_ROOT.id());

        } else if (key == KeyCode.Q) {
            fireButton(SQUARE.id());

        } else if (key == KeyCode.R) {
            fireButton(REVERSE.id());

            //Binary operations
        } else if (event.isShiftDown() && key == KeyCode.DIGIT5) {
            fireButton(PERCENT.id());

        } else if (key == KeyCode.MINUS || key == KeyCode.SUBTRACT) {
            fireButton(SUBTRACT.id());

        } else if (key == KeyCode.ADD ||
                event.isShiftDown() && key == KeyCode.EQUALS) {
            fireButton(ADD.id());

        } else if (key == KeyCode.MULTIPLY ||
                event.isShiftDown() && key == KeyCode.DIGIT8) {
            fireButton(MULTIPLY.id());

        } else if (key == KeyCode.SLASH || key == KeyCode.DIVIDE) {
            fireButton(DIVIDE.id());

        } else if (key == KeyCode.BACK_SPACE) {
            fireButton(LEFT_ERASE.id());

        } else if (key == KeyCode.EQUALS) {
            fireButton(RESULT.id());

        } else if (key == KeyCode.ENTER) {
            fireButton(RESULT.id());
            if (isMemoryStorageShown) {
                showOrHideMemoryPane();
            }

            // Digits and point
        } else if (key.isDigitKey()) {
            fireButton(key.getName());

        } else if (key == KeyCode.PERIOD || key == KeyCode.DECIMAL) {
            fireButton(POINT_BUTTON_ID);

        } else if (key == KeyCode.SPACE || key == KeyCode.ESCAPE) {
            fireButton(CLEAN.id());
            if (isMemoryStorageShown) {
                showOrHideMemoryPane();
            }
        }
    }

    /**
     * Searches a {@link Button} by the given code. If find fires an {@link ActionEvent}
     * and adds a button clicked visual effect for it.
     *
     * @param code a string value of a code to find button
     */
    private void fireButton(String code) {
        Platform.runLater(() -> {
            String keyCode = code;
            if (code.contains(NUMPAD_PREFIX)) {
                keyCode = code.substring(NUMPAD_PREFIX.length());
            }
            for (Node child : numbersAndOperations.getChildren()) {
                fireButtonImpl(keyCode, child);
            }
        });
    }

    /**
     * Checks the given button for an equivalence it's text and specified code. If they are
     * equal and this button is active and visible fires an {@link ActionEvent}.
     *
     * @param buttonId the required button's code
     * @param child    the button to check and fire
     */
    private void fireButtonImpl(String buttonId, Node child) {
        Button button = (Button) child;
        String currentButtonId = button.getId();
        if (currentButtonId.equalsIgnoreCase(buttonId) &&
                !button.isDisable() &&
                button.isVisible()) {

            addButtonClickedEffect(button);
            button.fire();
        }
    }

    /**
     * Adds a visual effect for button pressing.
     *
     * @param button the button to add a button pressed effect
     */
    private void addButtonClickedEffect(Button button) {
        button.arm();
        // add delay to show a button pressed effect
        PauseTransition pause = new PauseTransition(Duration.millis(50));
        pause.setOnFinished(event1 -> button.disarm());
        pause.play();
    }

    /**
     * Handles {@link ActionEvent} and {@link MouseEvent} for buttons with numbers, mathematical,
     * memory and edit operations. Updates text fields with history and current number.
     *
     * @param event an {@link ActionEvent} and {@link MouseEvent} occurred on button with number or operation
     */
    @FXML
    private void handleButtonEvent(Event event) {
        if (isViewPanelShown) {
            showOrHideViewPanel();
        }
        Button button = (Button) event.getSource();
        String textToSet;
        try {
            textToSet = handleButtonEventImpl(button);
        } catch (CalculationException e) {
            textToSet = handleException(e);
        }

        setCurrentNumber(textToSet);
        updateHistoryExpression();
        if (isErrorOccurred) {
            valueProcessor.cleanAll();
        }
    }

    /**
     * Executes an action for the specified button extracted from occurred event. For example, executes a mathematical
     * operation or adds digit from button to the current number or cleans all text fields. Returns the text to set
     * in the field with current number.
     *
     * @param button a button extracted from event
     * @return the text to set in the field with current number
     * @throws CalculationException if some error occurred while data processing
     */
    private String handleButtonEventImpl(Button button) throws CalculationException {
        String buttonId = button.getId();
        String textToSet = currentNumberText.getText();

        // if it is digit button
        if (isNumber(buttonId)) {
            resetAfterError();
            String buttonText = button.getText();
            boolean isDigitAppended = false;
            if (isDigit(buttonText)) {
                isDigitAppended = valueProcessor.enterDigit(Integer.parseInt(buttonText));
            }
            if (isDigitAppended) {
                textToSet = formatEnteredNumber(valueProcessor.getLastNumber());
            }
        }

        // if it is a button with decimal point
        if (POINT_BUTTON_ID.equals(buttonId)) {
            valueProcessor.addPoint();
            String currentNumber = formatEnteredNumber(valueProcessor.getLastNumber());
            if (!currentNumber.contains(POINT)) {
                currentNumber += POINT;
            }
            textToSet = currentNumber;
        }

        // if it is a button with mathematical operation
        MathOperation mathOperation = MathOperation.getOperation(buttonId);
        if (mathOperation != null) {
            textToSet = executeMathOperation(mathOperation);
        }

        // if it is a button with memory operation
        MemoryOperation memoryOperation = MemoryOperation.getOperation(buttonId);
        if (memoryOperation != null) {
            textToSet = executeMemoryOperation(memoryOperation);
        }

        // if it is a button with edit operation
        EditOperation editOperation = EditOperation.getOperation(buttonId);
        if (editOperation != null) {
            textToSet = executeEditOperation(editOperation);
        }
        return textToSet;
    }

    /**
     * Executes a mathematical operation appropriate to the button extracted from event and returns the result to set
     * in the text field with current number.
     *
     * @param operation a mathematical operation to execute
     * @return the result of the specified operation to set in the text field with current number
     * @throws CalculationException if some error occurred while calculations
     */
    private String executeMathOperation(MathOperation operation) throws CalculationException {
        BigDecimal result;
        if (operation != RESULT) {
            result = valueProcessor.executeMathOperation(operation);
        } else {
            resetAfterError();
            result = valueProcessor.calculateResult();
        }
        return formatNumberForDisplaying(result);
    }

    /**
     * Executes an operation with memorized value appropriate to the button extracted from event. Returns the last
     * entered number or memorized value if operation is memory recall. Also enables or disables some memory buttons
     * depends on what memory operation it is.
     *
     * @param operation an operation with memorized value appropriate to the button extracted from event
     * @return the last entered number or memorized value of operation is memory recall
     * @throws CalculationException if some error occurred while calculations
     */
    private String executeMemoryOperation(MemoryOperation operation) throws CalculationException {
        valueProcessor.executeMemoryOperation(operation);

        if (operation == MEMORY_CLEAN) {
            enableMemoryStateButtons(false);
        } else {
            enableMemoryStateButtons(true);
        }
        return formatNumberForDisplaying(valueProcessor.getLastNumber());
    }

    /**
     * Executes an edit operation appropriate to the button extracted from event. Returns the value of the modified
     * last entered number. Also resets text fields values and enables operation buttons after previous error.
     *
     * @param operation an edit operation to execute
     * @return the value of the modified last entered number
     * @throws CalculationException if last entered value is not a number
     */
    private String executeEditOperation(EditOperation operation) throws CalculationException {
        resetAfterError();
        if (operation == CLEAN) {
            valueProcessor.cleanAll();
            isErrorOccurred = false;

        } else if (operation == CLEAN_CURRENT) {
            valueProcessor.cleanCurrent();
            isErrorOccurred = false;

        } else if (operation == LEFT_ERASE) {
            valueProcessor.deleteLastDigit();
        }
        return formatEnteredNumber(valueProcessor.getLastNumber());
    }

    /**
     * Resets after error content of text fields to default values and enables all buttons that must be active by default.
     */
    private void resetAfterError() throws CalculationException {
        if (isErrorOccurred) {
            enableAllOperations(true);
            setCurrentNumber(formatNumberForDisplaying(valueProcessor.getLastNumber()));
            updateHistoryExpression();
            isErrorOccurred = false;
        }
    }

    /**
     * Returns a message with information about exception and disables all buttons with mathematical
     * operations, including memory add, subtract and store buttons.
     *
     * @param e an occurred exception instance
     * @return a message with information about exception
     */
    private String handleException(Exception e) {
        enableMemoryStateButtons(false);
        enableAllOperations(false);
        isErrorOccurred = true;
        return e.getMessage();
    }

    /**
     * Sets the given number represented by string to the textfield contains current number.
     *
     * @param number the number to set
     */
    private void setCurrentNumber(String number) {
        Platform.runLater(() -> {
            currentNumberText.setText(number);
            currentNumberText.end();
            prevOperationsText.end();
        });
    }

    /**
     * Sets the given string containing mathematical expression to the appropriate textfield.
     */
    private void updateHistoryExpression() {
        String history = valueProcessor.getExpression();
        Platform.runLater(() -> {
            prevOperationsText.setText(history);
            prevOperationsText.end();
        });

    }

    /**
     * Handles an event generated by showing a tooltip. Sets the location of tooltip relies on current mouse position.
     *
     * @param event an event generated by showing a tooltip
     */
    @FXML
    private void setTooltipPosition(Event event) {
        Tooltip tooltip = (Tooltip) event.getSource();
        Point mouse = MouseInfo.getPointerInfo().getLocation();
        tooltip.setX(mouse.getX() - 50);
        tooltip.setY(mouse.getY() - 55);
    }

    /**
     * Shows or hides a panel with calculator view types.
     */
    @FXML
    private void showOrHideViewPanel() {
        Timeline timeline;
        if (isViewPanelShown) { // if panel is already shown - hide it

            timeline = new Timeline(
                    getKeyFrame(0, VIEW_PANEL_MAX_WIDTH),
                    getKeyFrame(ANIMATION_DURATION, 0));

        } else { // if panel is invisible - show it
            // add list of calculator's view types
            viewTypesList.setItems(getListOfCalcTypes());
            viewTypesList.getSelectionModel().select(0);
            viewTypesPanel.setVisible(true);

            timeline = new Timeline(
                    getKeyFrame(0, 0),
                    getKeyFrame(ANIMATION_DURATION, VIEW_PANEL_MAX_WIDTH));
        }
        timeline.play();
        // add delay for animation complete
        PauseTransition pause = new PauseTransition(Duration.millis(ANIMATION_DURATION));
        pause.setOnFinished(event1 -> viewTypesPanel.setVisible(isViewPanelShown));
        pause.play();
        isViewPanelShown = !isViewPanelShown;
    }

    /**
     * Returns a {@link KeyFrame} instance configured with the given animation duration in millis and
     * end width value.
     *
     * @param animationDurationMS a value of animation duration in millis
     * @param endWidthValue       a value of an end width
     * @return a {@link KeyFrame} instance configured with the given parameters
     */
    private KeyFrame getKeyFrame(int animationDurationMS, double endWidthValue) {
        return new KeyFrame(Duration.millis(animationDurationMS), getKeyValue(endWidthValue));
    }

    /**
     * Returns a {@link KeyValue} instance configured with the given end value for the preferred width parameter.
     *
     * @param endValue the end value of width
     * @return a {@link KeyValue} instance configured with the given end value for the preferred width parameter
     */
    private KeyValue getKeyValue(double endValue) {
        return new KeyValue(viewTypesPanel.prefWidthProperty(), endValue);
    }

    /**
     * Returns the list of calculator view types.
     *
     * @return the list of calculator view types
     */
    private ObservableList<Label> getListOfCalcTypes() {
        List<Label> labelList = new LinkedList<>();

        for (String type : CALCULATOR_TYPES) {
            Label label = new Label(type);
            if (CONVERTER_GROUP.equals(type)) {
                label.setFont(CONVERTER_FONT);
            }
            labelList.add(label);
        }
        return FXCollections.observableList(labelList);
    }

    /**
     * Shows or hides a panel with memorized value.
     */
    @FXML
    private void showOrHideMemoryPane() {
        if (isMemoryStorageShown) { // if pane is already shown - hide it
            memoryStorage.setVisible(false);
            isMemoryStorageShown = false;
            enableMemoryStateButtons(true);
            enableAllButtons(true);
        } else { // if pane is invisible - show it
            memoryStorage.setVisible(true);
            isMemoryStorageShown = true;
            enableMemoryStateButtons(false);
            enableAllButtons(false);
        }
        memoryShow.setDisable(false);
    }

    /**
     * Enables or disables all mathematical operations, including memory add, subtract and store buttons depends
     * on the specified boolean value.
     *
     * @param enable a boolean value shows to enable or disable buttons
     */
    private void enableAllOperations(boolean enable) {
        enableMemoryEditButtons(enable);
        Platform.runLater(() -> {
            for (Node children : numbersAndOperations.getChildren()) {
                Button button = (Button) children;
                enableOperationButton(button, enable);
            }
        });
    }

    /**
     * Enables or disables memory store, add and subtract buttons depends on the specified boolean value.
     *
     * @param enable a boolean value shows to enable or disable buttons
     */
    private void enableMemoryEditButtons(boolean enable) {
        memoryAdd.setDisable(!enable);
        memorySubtract.setDisable(!enable);
        memoryStore.setDisable(!enable);
    }

    /**
     * Disables or enables memory recall, clean and store buttons depends on the specified boolean value.
     *
     * @param enable a boolean value shows to enable or disable buttons
     */
    private void enableMemoryStateButtons(boolean enable) {
        memoryRecall.setDisable(!enable);
        memoryClean.setDisable(!enable);
        memoryShow.setDisable(!enable);
    }

    /**
     * Disables or enables the given button.
     *
     * @param button a button to disable or enable
     * @param enable a boolean value shows to enable or disable buttons
     */
    private void enableOperationButton(Button button, boolean enable) {
        String buttonId = button.getId();
        MathOperation operation = MathOperation.getOperation(buttonId);
        String buttonText = button.getText();
        if (operation != null && operation != RESULT ||
                POINT.equals(buttonText)) {
            button.setDisable(!enable);
        }
    }

    /**
     * Disables or enables all buttons with numbers and math operations.
     *
     * @param enable a boolean value shows to enable or disable buttons
     */
    private void enableAllButtons(boolean enable) {
        enableMemoryEditButtons(enable);
        Platform.runLater(() -> {
            for (Node node : numbersAndOperations.getChildren()) {
                node.setDisable(!enable);
            }
        });
    }
}