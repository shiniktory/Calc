package com.implemica.CalculatorProject.controller;

import com.implemica.CalculatorProject.calculation.MathOperation;
import com.implemica.CalculatorProject.calculation.MemoryOperation;
import com.implemica.CalculatorProject.exception.CalculationException;
import com.implemica.CalculatorProject.processing.InputValueProcessor;
import javafx.animation.KeyFrame;
import javafx.animation.KeyValue;
import javafx.animation.Timeline;
import javafx.collections.FXCollections;
import javafx.concurrent.Task;
import javafx.event.ActionEvent;
import javafx.event.Event;
import javafx.fxml.FXML;
import javafx.scene.Node;
import javafx.scene.control.Button;
import javafx.scene.control.ListView;
import javafx.scene.control.TextField;
import javafx.scene.control.Tooltip;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.VBox;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.scene.text.Text;
import javafx.util.Duration;

import java.awt.*;

import static com.implemica.CalculatorProject.calculation.EditOperation.*;
import static com.implemica.CalculatorProject.calculation.EditOperation.LEFT_ERASE;
import static com.implemica.CalculatorProject.calculation.MathOperation.*;
import static com.implemica.CalculatorProject.calculation.MemoryOperation.MEMORY_CLEAN;
import static com.implemica.CalculatorProject.util.OutputFormatter.EMPTY_VALUE;
import static com.implemica.CalculatorProject.util.OutputFormatter.POINT;

/**
 * The {@code CalculatorController} class is a chain between calculator's view and calculations. It accepts and handles
 * events generated by mouse clicks or keyboard keys' pressings.
 *
 * @author V. Kozina-Kravchenko
 */
public class CalculatorController {

    /**
     * An instance of {@link InputValueProcessor} that accepts, transforms and calculates the results for an
     * input data.
     */
    private InputValueProcessor valueProcessor = new InputValueProcessor();

    private static final Font DEFAULT_FONT = Font.font("Malgun Gothic Bold", FontWeight.BOLD, 42);

    private static final String NUMPAD_PREFIX = "Numpad ";


    private String[] types = new String[]{"\tStandard", "\tScientific", "\tProgrammer", "\tDate calculation", "\tCONVERTER", "\tVolume", "\tLength",
            "\tWeight and Mass", "\tTemperature", "\tEnergy", "\tArea", "\tSpeed", "\tTime", "\tPower", "\tData", "\tPressure", "\tAngle"};

    private static final int ANIMATION_DURATION = 75;

    private boolean isViewPanelShown = false;

    /**
     * An instance of text field with a value of current number value.
     */
    @FXML
    private TextField currentNumberText;

    /**
     * An instance of text field with a string containing previous number and arithmetic operation.
     */
    @FXML
    private TextField prevOperationsText;

    @FXML
    private VBox viewPanel;

    @FXML
    private ListView<String> viewTypes;

    @FXML
    private GridPane numbersAndOperations;

    @FXML
    private GridPane memoryButtonsPane;

    @FXML
    private Button mc, mr, m, mPlus, mMinus, ms;

    private boolean isErrorOccurred = false;

    protected TextField getCurrentNumberText() {
        return currentNumberText;
    }

    protected TextField getPrevOperationsText() {
        return prevOperationsText;
    }

    protected void searchAndFireButton(String code) {
        numbersAndOperations.requestFocus();
        String keyCode = code;
        if (code.contains(NUMPAD_PREFIX)) {
            keyCode = code.substring(NUMPAD_PREFIX.length());
        }
        // Search in node with numbers and operations
        boolean found = false;
        for (Node child : numbersAndOperations.getChildren()) {
            found = checkAndFire(keyCode, child);
        }
        if (!found) {
            // Search in node with memory operations
            for (Node child : memoryButtonsPane.getChildren()) {
                checkAndFire(keyCode, child);
            }
        }
    }

    private boolean checkAndFire(String buttonId, Node child) {
        Button button = (Button) child;
        if (button.getText().equals(buttonId) && !button.isDisable()) {
            addButtonClickedEffect(button);
            button.fire();
            return true;
        }
        return false;
    }

    private void addButtonClickedEffect(Button button) {
        button.arm();
        Task<Void> sleeper = new Task<Void>() {
            @Override
            protected Void call() throws Exception {
                try {
                    Thread.sleep(50);
                } catch (InterruptedException e) {
                    //ignore
                }
                return null;
            }
        };
        sleeper.setOnSucceeded(event1 -> button.disarm());
        new Thread(sleeper).start();
    }

    /**
     * Reads a value of the current number from calculator's text field.
     *
     * @param event an instance of event generated after button with number pressed.
     */
    @FXML
    private void readCurrentNumber(Event event) {
        hideViewPanel();
        resetAfterError();
        String buttonValue = getNumberFromEvent(event);
        try {
            valueProcessor.updateCurrentNumber(buttonValue);
            updateCurrentNumberField();
        } catch (CalculationException e) {
            fitText(e.getMessage());
            currentNumberText.setText(e.getMessage());
            disableAllOperations();
            isErrorOccurred = true;
        }
    }

    /**
     * Extracts from occurred event a value of input number represented as string.
     *
     * @param event an instance of occurred event
     * @return a value of input number represented as string
     */
    private String getNumberFromEvent(Event event) {

        if (event instanceof MouseEvent || event instanceof ActionEvent) {
            return ((Button) event.getSource()).getText();
        }
        return EMPTY_VALUE;
    }

    /**
     * Updates a value of current number in the appropriate text field.
     */
    private void updateCurrentNumberField() {
        String textToSet;
        try {
            textToSet = valueProcessor.getLastNumber();
        } catch (CalculationException e) {
            textToSet = e.getMessage();
            disableAllOperations();
            isErrorOccurred = true;
        }
        fitText(textToSet);
        currentNumberText.setText(textToSet);
    }

    /**
     * Handles all events generated by keyboard key pressing.
     *
     * @param event an event instance generated by key pressing
     */
    @FXML
    private void keyEventHandler(KeyEvent event) {
        KeyCode key = event.getCode();
        hideViewPanel();

        // Unary operations
        if (event.isShiftDown() && key == KeyCode.DIGIT2) {
            searchAndFireButton(SQUARE_ROOT.getCode());

            //Binary operations
        } else if (event.isShiftDown() && key == KeyCode.DIGIT5) {
            searchAndFireButton(PERCENT.getCode());

        } else if (key == KeyCode.MINUS || key == KeyCode.SUBTRACT) {
            searchAndFireButton(SUBTRACT.getCode());

        } else if (key == KeyCode.ADD ||
                event.isShiftDown() && key == KeyCode.EQUALS) {
            searchAndFireButton(ADD.getCode());

        } else if (key == KeyCode.MULTIPLY ||
                event.isShiftDown() && key == KeyCode.DIGIT8) {
            searchAndFireButton(MULTIPLY.getCode());

        } else if (key == KeyCode.SLASH || key == KeyCode.DIVIDE) {
            searchAndFireButton(DIVIDE.getCode());

        } else if (key == KeyCode.BACK_SPACE) {
            searchAndFireButton(LEFT_ERASE.getCode());

        } else if (key == KeyCode.EQUALS || key == KeyCode.ENTER) {
            searchAndFireButton(EQUAL.getCode());

            // Digits and point
        } else if (key.isDigitKey()) {
            searchAndFireButton(key.getName());
        } else if (key == KeyCode.PERIOD || key == KeyCode.DECIMAL) {
            searchAndFireButton(POINT);
        } else if (key == KeyCode.SPACE) {
            searchAndFireButton(CLEAN.getCode());
        } else if (key == KeyCode.ESCAPE) {
            searchAndFireButton(CLEAN_EVERYTHING.getCode());
        }
    }

    /**
     * Handles events generated by Mouse clicks on buttons with operations.
     *
     * @param event an event instance generated by Mouse click on button with operation
     */
    @FXML
    private void operationsHandler(Event event) {
        hideViewPanel();
        MathOperation operation = getOperationFromEvent(event);
        if (operation == null) {
            return;
        }
        String textToSet;
        try {
            textToSet = valueProcessor.executeMathOperation(operation);
        } catch (CalculationException e) {
            textToSet = e.getMessage();
            disableAllOperations();
            isErrorOccurred = true;
        }
        fitText(textToSet);
        currentNumberText.setText(textToSet);
        prevOperationsText.setText(valueProcessor.getExpression());
        if (isErrorOccurred) {
            valueProcessor.cleanAll();
        }
    }

    /**
     * Extracts an {@link MathOperation} from the given event.
     *
     * @param event an instance of generated event
     * @return an {@link MathOperation} extracted from the given event
     */
    private MathOperation getOperationFromEvent(Event event) {
        Button buttonClicked = (Button) event.getSource();
        String operationSymbol = buttonClicked.getText();
        return MathOperation.getOperation(operationSymbol);
    }

    /**
     * Updates values in text fields with current number and previous operations.
     */
    private void updateTextFields() {
        prevOperationsText.setText(valueProcessor.getExpression());
        updateCurrentNumberField();
    }

    /**
     * Handles an event generated by pressing the Calculate button. Calculates the result and shows it
     * in an appropriate text field.
     */
    @FXML
    private void calculateResult() {
        resetAfterError();
        String textToSet;
        try {
            textToSet = valueProcessor.calculateResult();
        } catch (CalculationException e) {
            textToSet = e.getMessage();
            valueProcessor.cleanAll();
            disableAllOperations();
            isErrorOccurred = true;
        }
        fitText(textToSet);
        currentNumberText.setText(textToSet);
        if (!isErrorOccurred) {
            prevOperationsText.clear();
        }
    }

    private void resetAfterError() {
        if (isErrorOccurred) {
            enableAllOperations();
            updateTextFields();
            isErrorOccurred = false;
        }
    }

    /**
     * Adds a point symbol to the current number.
     */
    @FXML
    private void addPoint() {
        valueProcessor.addPoint();
        updateCurrentNumberField();
    }

    /**
     * Cleans all text fields and saved values.
     */
    @FXML
    private void cleanAll() {
        resetAfterError();
        valueProcessor.cleanAll();
        updateTextFields();
        enableAllOperations();
        isErrorOccurred = false;
    }

    /**
     * Cleans text field with the current entered number.
     */
    @FXML
    private void cleanCurrent() {
        resetAfterError();
        valueProcessor.cleanCurrent();
        updateCurrentNumberField();
        enableAllOperations();
        isErrorOccurred = false;
    }

    /**
     * Deletes the last symbol in the current entered number.
     */
    @FXML
    private void deleteLastNumber() {
        resetAfterError();
        try {
            valueProcessor.deleteLastDigit();
            updateCurrentNumberField();
        } catch (CalculationException e) {
            fitText(e.getMessage());
        }

    }

    /**
     * Handles events generated by mouse click on memory buttons.
     *
     * @param event an instance of event generated by mouse click on memory buttons
     */
    @FXML
    private void memoryButtonHandler(Event event) {
        String operationCode = ((Button) event.getSource()).getText();
        MemoryOperation operation = MemoryOperation.getOperation(operationCode);
        if (operation == MEMORY_CLEAN) {
            disableMemoryButtons();
            return;
        }
        String textToSet;
        try {
            valueProcessor.executeMemoryOperation(operation);
            textToSet = valueProcessor.getLastNumber();
            enableMemoryButtons();
        } catch (CalculationException e) {
            textToSet = e.getMessage();
        }
        fitText(textToSet);
        currentNumberText.setText(textToSet);
        numbersAndOperations.requestFocus();
    }

    private void enableMemoryButtons() { // TODO change with using MemoryPane
        mr.setDisable(false);
        mc.setDisable(false);
        m.setDisable(false);
        numbersAndOperations.requestFocus();
    }

    private void disableMemoryButtons() {
        mr.setDisable(true);
        mc.setDisable(true);
        m.setDisable(true);
        numbersAndOperations.requestFocus();
    }

    private void disableAllOperations() {
        disableMemoryButtons();
        mPlus.setDisable(true);
        mMinus.setDisable(true);
        ms.setDisable(true);
        for (Node children : numbersAndOperations.getChildren()) {
            Button thisButton = (Button) children;
            if (MathOperation.getOperation(thisButton.getText()) != null &&
                    !thisButton.getText().equals(EQUAL.getCode()) ||
                    POINT.equals(thisButton.getText())) {
                thisButton.setDisable(true);
            }
        }
    }

    private void enableAllOperations() {
        mPlus.setDisable(false);
        mMinus.setDisable(false);
        ms.setDisable(false);
        for (Node children : numbersAndOperations.getChildren()) {
            Button thisButton = (Button) children;
            if (MathOperation.getOperation(thisButton.getText()) != null || POINT.equals(thisButton.getText())) {
                thisButton.setDisable(false);
            }
        }
    }


    private void fitText(String currentText) {
        currentNumberText.setFont(DEFAULT_FONT);

        Text text = new Text(currentText);
        text.setFont(currentNumberText.getFont());
        currentNumberText.applyCss();

        double width = text.getLayoutBounds().getWidth();
        double scale = currentNumberText.getBoundsInLocal().getWidth() / width;
        if (scale < 1.0) {
            currentNumberText.setFont(new Font(currentNumberText.getFont().getSize() * scale));
        }
    }

    @FXML
    private void setTooltipPosition(Event event) {
        Tooltip tooltip = (Tooltip) event.getSource();
        Point mouse = MouseInfo.getPointerInfo().getLocation();
        tooltip.setX(mouse.getX() - 50);
        tooltip.setY(mouse.getY() - 55);
        numbersAndOperations.requestFocus();
    }

    @FXML
    private void showViewPanel() {
        viewTypes.setItems(FXCollections.observableArrayList(types));
        viewTypes.getSelectionModel().select(0);

        viewPanel.setVisible(true);
        Timeline timeline = new Timeline(
                new KeyFrame(Duration.ZERO, new KeyValue(viewPanel.prefWidthProperty(), 0.0)),
                new KeyFrame(Duration.millis(ANIMATION_DURATION), new KeyValue(viewPanel.prefWidthProperty(), 257.0))
        );

        timeline.play();
        isViewPanelShown = true;
        numbersAndOperations.requestFocus();
    }

    @FXML
    private void hideViewPanel() {
        if (isViewPanelShown) {
            Timeline timeline = new Timeline(
                    new KeyFrame(Duration.ZERO, new KeyValue(viewPanel.prefWidthProperty(), 257.0)),
                    new KeyFrame(Duration.millis(ANIMATION_DURATION), new KeyValue(viewPanel.prefWidthProperty(), 0.0))
            );
            timeline.play();
            Task<Void> sleeper = new Task<Void>() {
                @Override
                protected Void call() throws Exception {
                    try {
                        Thread.sleep(ANIMATION_DURATION);
                    } catch (InterruptedException e) {
                        //ignore
                    }
                    return null;
                }
            };
            sleeper.setOnSucceeded(event1 -> viewPanel.setVisible(false));
            new Thread(sleeper).start();
            isViewPanelShown = false;
        }
        numbersAndOperations.requestFocus();
    }


    // TODO try to change font to Arial Unicode ms
    // TODO make font scale with window size
}